
1. 全排列思考
   对一个length为n数组进行全排列，相当一个空数组有n个位置待填入数字，
   第 1 个位置，有n种选择，
   第 2 个位置，有n-1种选择
   ....
   第n-1个位置，有2种选择
   第 n 个位置，有1种选择
   我们可以用回溯的方式来寻找所有的解，回溯时，
   对于每一层使用循环，遍历当前层剩余可用的数字列表，对于遍历到的每一个数字，填入空数组中对应位置，
   然后递归进入下一层，回来时，进行必要的reverse status，然后下一个数字的迭代。直到当前层所有
   可用的数遍历完

   若进行全排列的数组当中有重复数字，且我们需要保证全排列结果没有重复结果时，我们则需要在每一层遍历
   剩余可用值时，需要跳过那些之前已经在【当层】遍历的值，这样就可以保证没有重复结果。
   例如假设回溯进入第4层，此时空数组已经填入3个数值:[1,2,3 (), (), ()], 还剩余3个数值 4① 4② 5待填入
   那对于第四个位置，假设我们填入第一个4①，则进入下一层递归时，相当于拿[1,2,3,4①]的确定组合与剩余数值[4②,5]的全排列进行拼装
   得到结果：[1,2,3,4①, (4②), (5)] 与 [1,2,3,4①, (5), (4②)]
   第四个位置如果填入是第二个4②，依然是求解[1,2,3,4②]的确定组合与剩余数值[4①,5]的全排列进行拼装
   必然是所有结果都与之前的重复

   时间：O(N!)
   正如上面描述，第一个位置有n种选择，第二个位置有n-1种... 最后一个位置只有一种，这状态的组合便是N的阶乘 N!

   空间：O(N)
   每一次方法递归调用只消耗额外O(1)的空间，最大栈深度为N，因此最大额外空间为O(N)

2. 子集思考
    方法一：
        思路：
            第一种方式，也是感觉比较简单的思维方式，对于每一个数，我们都有确切的
            两种状态：①在子集种，
            ②不在子集种。
            相当于每一个数都有两种状态，将每个数的每种状态进行组合便能得到所有子集。但是这种思维方式对于
            数组中存在重复元素，去重时似乎会存在难度。
        复杂度：
            时间：O(2^N)。一共2^n种状态
            空间：O(N)
            有一个用于存储路径的List<Ingeger>，以及递归消耗的栈空间，都取决于状态树高，状态树最高为n
            因此空间复杂度为O(N)
   
    方法二：
        思路：
            对于有n个数的数组，其子集是
            0.   空集合
            1.   从n个数中选 1 个数的所有组合
            2.   从n个数中选 2 个数的所有组合
                 .....
            n-1. 从n个数种选n-1个数的所有组合
            n.   本身
            
            以上所有组合的集合便是子集
            
            代码:
            private void backtrace(int[] nums, int index, List<Integer> path, List<List<Ingeger>> results) {
                results.add(new ArrayList(path));
                
                for(int i = index; i < nums.length; i++) {
                    path.add(nums[i])
                    backtrace(nums, index + 1, path, results);
                    path.remove(path.size() - 1);
                }
            }


3. 二叉树的最近公共祖先
    解法一：
        思路：
           都知道树的问题通常都用递归来解决，因为树本身就具有重复性，但是这个问题我能想到
           的最简单方式是使用【递归】求出p,q两个节点的访问路径，并分别存储到【栈】中。
           然后两个栈的底部必然有一部分相同的栈元素，距离栈顶最近且相同的元素便是最近公共祖先
           例如下树：

   				         [3]
   			  [5]     	           [1]
   		[6]       [2]	      [0]		[8]
   			   [7]   [4]
   		
   		访问元素7需要经过的路径栈为:
   		
   		栈顶 [7]
   			 [2]
   			 [5]
   		栈底 [3]
   		------------------------------------
   		访问元素6需要经过的路径栈为:
   		
   		栈顶 [6]
   			 [5]
   		栈底 [3]
   		---------------------------------------
   		从两个栈从底部到顶部，最大公共部分就是[3] [5]，
   		所以最近公共祖先是5
   		
   	复杂度：
   		时间：O(2N)
   			查找一个节点的访问路径，最坏的情况需要遍历所有节点，因此为O(n)，两个节点便需要O(2n)
   		空间：O(2logN)
   			题中为二叉树，不会是退化为链表的树，存储一个节点的访问路径到栈中，
   			栈最大深度等于二叉树最大树深度为O(logn)，两个节点需要O(2logN)

   解法二：
   思路：
   分别递归的去左右子树中找，
   1. 左右子树的返回值都不为NULL，说明当前结点就是两个结点公共祖先，
   2. 两边都返回NULL,某些子树中不存在p、q的情况
   3. 一边返回NULL一边返回非NULL,公共祖先找到的情况或者当前子树中找到了p、q之一的情况

   		注意两边都返回非NULL的情况在题目中是唯一的，因为所有值都唯一，并且p、q一定存在在树中，
   		同时当找到这个公共祖先后向上层返回的过程中
   		后续上层的root结点其一定是左右两边一边返回NULL，一边返回非NULL，
   		所以这个公共祖先会被顺利的返回
   		因此不会出现返回的公共祖先不是深度最深的那个。


   复杂度：
   	时间：O(n)
   		每个节点有且仅有被访问一次，所以为O(n)
   	空间：
   		最坏：O(N)  最好：O(logn)
   		空间主要递归所使用的栈的空间，递归的深度取决于树高度，在最坏情况树退化为链表
   		此时树高等于节点数N
   		
   		
   		环状链表  快慢指针



4.  从前序与中序遍历序列构造二叉树
    preorder第一个元素为root，在inorder里面找到root，在它之前的为左子树（长l1），之后为右子树（长l2）。
    preorder[1]到preorder[l1]为左子树,之后为右子树，分别递归。
	
	
	
	
	
	
	
	